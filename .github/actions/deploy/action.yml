inputs:
  aws_region:
    description: 'AWS runner region'
    default: 'us-east-1'
    required: false
  environment:
    description: 'Target environment to deploy'
    required: true
  version:
    description: 'Version to deploy as a git reference (branch, tag)'
    required: true
  docker_username:
    description: 'Docker Hub username'
    required: true
  docker_password:
    description: 'Docker Hub password'
    required: true
  eks_cluster_name:
    description: 'EKS cluster name (optional, will be auto-generated based on environment)'
    required: false
  aws_access_key_id:
    description: 'AWS Access Key ID'
    required: true
  aws_secret_access_key:
    description: 'AWS Secret Access Key'
    required: true

runs:
  using: "composite"
  steps:
    - name: Check version
      shell: bash -leo pipefail {0}
      run: python3 --version

    - name: Login to Docker Hub
      uses: docker/login-action@v3
      with:
        username: ${{ inputs.docker_username }}
        password: ${{ inputs.docker_password }}

    - name: üîß Set namespace
      shell: bash -leo pipefail {0}
      run: |
        # Map environment to correct namespace name
        if [ "${{ inputs.environment }}" = "staging" ] || [ "${{ inputs.environment }}" = "stage" ]; then
          NAMESPACE="devsu-demo-staging"
        elif [ "${{ inputs.environment }}" = "prod" ] || [ "${{ inputs.environment }}" = "production" ]; then
          NAMESPACE="devsu-demo-prod"
        else
          NAMESPACE="devsu-demo-${{ inputs.environment }}"
        fi
        echo "Using namespace: $NAMESPACE"
        echo "NAMESPACE=$NAMESPACE" >> $GITHUB_ENV

    - name: üîê Configure AWS credentials
      shell: bash -leo pipefail {0}
      run: |
        aws configure set aws_access_key_id ${{ inputs.aws_access_key_id }}
        aws configure set aws_secret_access_key ${{ inputs.aws_secret_access_key }}
        aws configure set region ${{ inputs.aws_region }}

    - name: üì¶ Install kubectl
      shell: bash -leo pipefail {0}
      run: |
        curl -LO "https://dl.k8s.io/release/$(curl -L -s https://dl.k8s.io/release/stable.txt)/bin/linux/amd64/kubectl"
        chmod +x kubectl
        sudo mv kubectl /usr/local/bin/

    - name: üîó Update kubeconfig for EKS
      shell: bash -leo pipefail {0}
      run: |
        # Set cluster name based on environment
        if [ "${{ inputs.environment }}" = "prod" ] || [ "${{ inputs.environment }}" = "production" ]; then
          EKS_CLUSTER_NAME="devsu-demo-prod-eks"
        elif [ "${{ inputs.environment }}" = "staging" ] || [ "${{ inputs.environment }}" = "stage" ]; then
          EKS_CLUSTER_NAME="devsu-demo-stage-eks"
        else
          EKS_CLUSTER_NAME="devsu-demo-${{ inputs.environment }}-eks"
        fi
        
        # Override with provided cluster name if specified
        if [ -n "${{ inputs.eks_cluster_name }}" ]; then
          EKS_CLUSTER_NAME="${{ inputs.eks_cluster_name }}"
        fi
        
        echo "Connecting to EKS cluster: $EKS_CLUSTER_NAME"
        aws eks update-kubeconfig --region ${{ inputs.aws_region }} --name $EKS_CLUSTER_NAME

    - name: üîç Verify cluster connection
      shell: bash -leo pipefail {0}
      run: |
        kubectl cluster-info
        kubectl get nodes

    - name: üöÄ Deploy to EKS
      shell: bash -leo pipefail {0}
      run: |
        # Update image tag in deployment YAML
        echo "Updating deployment with image: ${{ inputs.docker_username }}/devsu-demo:${{ inputs.version }}"
        
        # Create temporary deployment file with updated image
        if [ "${{ inputs.environment }}" = "prod" ] || [ "${{ inputs.environment }}" = "production" ]; then
          DEPLOYMENT_FILE="infrastructure/k8s/prod/deployment.yaml"
        elif [ "${{ inputs.environment }}" = "staging" ] || [ "${{ inputs.environment }}" = "stage" ]; then
          DEPLOYMENT_FILE="infrastructure/k8s/staging/deployment.yaml"
        else
          echo "Environment ${{ inputs.environment }} not supported"
          exit 1
        fi
        
        # Update image in deployment file
        sed -i "s|image: .*/devsu-demo:.*|image: ${{ inputs.docker_username }}/devsu-demo:${{ inputs.version }}|g" $DEPLOYMENT_FILE
        
        # Apply the deployment
        kubectl apply -f $DEPLOYMENT_FILE -n ${{ env.NAMESPACE }}
        
        # Also apply other resources if they exist
        kubectl apply -f infrastructure/k8s/${{ inputs.environment }}/ -n ${{ env.NAMESPACE }} || true

    - name: üîÑ Wait for deployment rollout
      shell: bash -leo pipefail {0}
      run: |
        kubectl rollout status deployment/devsu-demo-app -n ${{ env.NAMESPACE }} --timeout=300s

    - name: üìä Verify deployment
      shell: bash -leo pipefail {0}
      run: |
        kubectl get pods -n ${{ env.NAMESPACE }}
        kubectl get services -n ${{ env.NAMESPACE }}
        kubectl get ingress -n ${{ env.NAMESPACE }}